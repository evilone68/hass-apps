"""
This module implements the Thermostat class.
"""

import typing as T
if T.TYPE_CHECKING:
    # pylint: disable=cyclic-import,unused-import
    import uuid
    from ..room import Room

import copy
import json
import observable
import voluptuous as vol

from ... import common


class ActorBase:
    """An actor to be controlled by Schedy."""

    name = "actor"
    config_schema = vol.Schema(object)

    def __init__(self, entity_id: str, cfg: dict, room: "Room") -> None:
        self.entity_id = entity_id
        self.cfg = cfg
        self.room = room
        self.app = room.app
        self.current_value = None  # type: T.Any
        self.wanted_value = None  # type: T.Any
        self.resend_timer = None  # type: T.Optional[uuid.UUID]
        self.events = observable.Observable()  # type: observable.Observable

    def __repr__(self) -> str:
        return "<Actor {}>".format(str(self))

    def __str__(self) -> str:
        return "A:{}".format(self.cfg.get("friendly_name", self.entity_id))

    @staticmethod
    def _preprocess_state(state: T.Optional[dict]) -> dict:
        """Copies and flattens a state dict."""

        attrs = copy.deepcopy(state or {})
        attrs.update((attrs or {}).get("attributes", {}))
        return attrs

    def _resend_cb(self, kwargs: dict) -> None:
        """This callback triggers the actual sending of a value to the
        actor. Expected members of kwargs are:
        - left_tries (after this round)"""

        self.resend_timer = None

        left_tries = kwargs["left_tries"]
        self.log("Setting value {} (left tries = {})."
                 .format(self.wanted_value, left_tries),
                 level="DEBUG", prefix=common.LOG_PREFIX_OUTGOING)
        self.do_send()

        if not left_tries:
            return

        interval = self.cfg["resend_interval"]
        self.log("Re-sending in {} seconds."
                 .format(interval),
                 level="DEBUG")
        self.resend_timer = self.app.run_in(
            self._resend_cb, interval, left_tries=left_tries - 1
        )

    def _state_cb(
            self, entity: str, attr: str,
            old: T.Optional[dict], new: T.Optional[dict],
            kwargs: dict,
    ) -> None:
        """Is called when any of the actor's state attributes changes."""

        attrs = self._preprocess_state(new)

        previous_value = self.current_value
        self.notify_state_changed(attrs)

        if self.current_value == self.wanted_value:
            self.cancel_resend_timer()

        if self.current_value != previous_value:
            self.log("Received value of {}."
                     .format(repr(self.current_value)),
                     level="DEBUG", prefix=common.LOG_PREFIX_INCOMING)

    def after_initialization(self) -> None:
        """Can be implemented to perform actions after actor initialization."""

        pass

    def cancel_resend_timer(self) -> None:
        """Cancels the resend timer for this actor, if one exists."""

        timer = self.resend_timer
        if timer is None:
            return
        self.app.cancel_timer(timer)
        self.resend_timer = None
        self.log("Cancelled resend timer.", level="DEBUG")

    def check_config_plausibility(self, state: dict) -> None:
        """Is called during initialization to warn the user about some
        possible common configuration mistakes. The entity's current
        state attributes dictionary is provided."""

        pass

    @staticmethod
    def deserialize_value(value: str) -> T.Any:
        """Should deserialize a value generated by serialize_value().
        A ValueError should be raised in case of malformed data.
        This implementation uses JSON."""

        try:
            return json.loads(value)
        except (TypeError, json.JSONDecodeError) as err:
            raise ValueError("invalid JSON data: {}".format(repr(err)))

    def do_send(self) -> None:
        """This method should implement the actual sending of
        self.wanted_value to the actor."""

        pass

    def filter_set_value(self, value: T.Any) -> T.Any:  # pylint: disable=no-self-use
        """Should be implemented to decide whether to set the given
        value on this actor or to alter it before setting.
        The return value is either the actual value to set or None,
        if nothing should be sent."""

        return value

    @property
    def is_synced(self) -> bool:
        """Tells whether the actor's current value is the wanted one and
        no re-sending is in progress."""

        return self.resend_timer is None and \
               self.current_value == self.wanted_value

    def log(self, msg: str, *args: T.Any, **kwargs: T.Any) -> None:
        """Prefixes the actor to log messages."""
        msg = "[{}] {}".format(self, msg)
        self.room.log(msg, *args, **kwargs)

    def notify_state_changed(self, attrs: dict) -> None:
        """Is called when the entity's state has changed with the new
        attributes dict as argument. It should update self.current_value
        if appropriate."""

        pass

    def initialize(self) -> None:
        """Should be called in order to register state listeners and
        timers."""

        self.log("Initializing actor (entity_id={}, type={})."
                 .format(repr(self.entity_id), repr(self.name)),
                 level="DEBUG")

        self.log("Fetching initial state.",
                 level="DEBUG")
        state = self.app.get_state(self.entity_id, attribute="all")
        if state is None:
            self.log("State of actor entity is None, ignoring it for now.",
                     level="WARNING")
        else:
            self.check_config_plausibility(self._preprocess_state(state))
            # populate self.current_value etc. by simulating a
            # state change
            self._state_cb(self.entity_id, "all", state, state, {})

        self.log("Listening for state changes.",
                 level="DEBUG")
        self.app.listen_state(self._state_cb, self.entity_id, attribute="all")

        self.after_initialization()

    @classmethod
    def prepare_eval_environment(cls, env: T.Dict[str, T.Any]) -> None:
        """Should add any additional items to the dict used as environment
        for expression evaluation."""

        pass

    @staticmethod
    def serialize_value(value: T.Any) -> str:
        """Should serialize accepted values for this actor to str.
        A ValueError should be raised in case of not serializable data.
        This implementation uses JSON."""

        try:
            return json.dumps(value)
        except TypeError as err:
            raise ValueError("can't serialize to JSON: {}".format(err))

    def set_value(self, value: T.Any, force_resend: bool = False) -> bool:
        """Is called in order to change the actor's value. It isn't
        re-sent unless force_resend is True.
        The return value tells whether a value has been set."""

        value = self.filter_set_value(value)
        if value is None:
            return False

        self.wanted_value = value
        if not force_resend and self.is_synced:
            self.log("Not sending value {} redundantly."
                     .format(repr(value)),
                     level="DEBUG")
            return False

        self.cancel_resend_timer()
        self._resend_cb({"left_tries": self.cfg["send_tries"]})
        return True

    @staticmethod
    def validate_value(value: T.Any) -> T.Any:
        """Should validate the given value, which usually is the result
        of a custom expression, to ensure it's appropriate for this kind
        of actor. It may alter the value before returning it again.
        A ValueError should be raised when validation fails."""

        return value
